<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ref和reactive根本差別在哪裡 - 10 個 Vue3 開發上面的小細節 | 六角學院</title>
</head>
<body>
    <div id="app">
        <button @click="submitFn">Submit</button>
    </div>
    <script src="https://unpkg.com/vue@next"></script>
    <script>
        const { ref, reactive, watch } = Vue;
        
        const app = {
            setup() {

                //除了在不同情境使用的選擇以外
                //實際上ref和reactive根本差別在哪裡

                const refObject = ref({name: ""});
                //ref可以針對任何資料型別去做包裝，
                //但無法針對object和array的深層變動做監控
                //ref的第一層只有到value這個地方

                //const reactiveObject = reactive({name: ""});
                //const reactiveObject = reactive({name: {age:""}});
                //reactive只接受object和array這兩種資料型別，
                //但可以針對object和array的深層變動做監控

                const reactiveObject = reactive({name: ""});


                //如何優化效能，可以只針對object裡面的那個key去做監控
                //跳出黃色vue@next:1287 [Vue warn]: Invalid watch source:  
                //Mike A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types. 
                //at <App>
                //因為watch要用一個函式()=>返回回去

                watch(
                    ()=> reactiveObject.name, 
                    (newVal)=>{
                        console.log("reactive=>", newVal);
                        //印出結果:
                        //reactive=> Mike
                    }
                );

                watch(
                    ()=> refObject.value.name, 
                    (newVal)=>{
                        console.log("ref=>", newVal);
                        //印出結果:
                        //ref=> Jacky
                    }
                );
                
                //watch(reactiveObject, (newVal)=>{
                    //console.log("reactive=>", newVal);
                    //印出結果:
                    //reactive=> Proxy {name: "Mike"}
                    //槽狀結構印出結果:
                    //Proxy {name: {…}, age: "12"}
                        //[[Target]]: Object
                        // age: "12"
                        // name: {age: ""}
                        // __proto__: Object
                        // [[IsRevoked]]: false
                //});

                // watch(refObject, 
                //     (newVal)=>{
                //         console.log("ref=>", newVal);
                //         //正常印出結果:
                //         //沒有印出任何東西
                //         //deep後印出結果:
                //         //ref=> Proxy {name: "Jacky"}
                //     }
                //     //,{deep: true} 
                //     //不推薦deep的作法，
                //     //因為效能會變差，它會直接去掃過object所有階層
                // );

                const submitFn = () => {
                    //ref包裝起來的東西不管是不是物件都要用.value去取出
                    refObject.value.name = "Jacky";
                    reactiveObject.name = "Mike";
                    //reactiveObject.age = "12";

                    //console.log(refObject);
                    //印出結果:
                    // {
                    //     "_rawValue": {
                    //         "name": "Jacky"
                    //     },
                    //  ...中略
                    // }
                    //可以看出其實資料是有改變!
                    //console.log(reactiveObject);
                    //印出結果:
                    //Proxy {name: "Mike"}
                    
                };
                
                return {
                    submitFn
                };
            }
        };

        Vue.createApp(app).mount("#app");
    </script>
</body>
</html>